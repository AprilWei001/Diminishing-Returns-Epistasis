# Diminishing-Returns-Epistasis
Data and code from Wei and Zhang, 2018

Data and results: in "*.xlsx" 
Code: in "*.m"

List of files: Name (description).
  
  Experimental data generated in this study:
  
    PixelFromScanAndCountCellFromFlowcyto.xlsx	(colums: 1&2 pixel number from scanning, 3&4 cell number counted from flow cytometry, rows: segregants)	
    ColonyPixelNumberAcross48Hour.xlsx (column: time, row: segregant, attribute: pixel number; logPixel/(2pi) is average growth rate)
    
  Analytical results from published data:
  
    AlleleFrequencyTestPValue.xlsx (row: SNP, column: environment, attribute: p-value from binomial test without multiple testing correction. This file can be used to extract whether the allele frequency for each SNP of all phenotyped segregants diviates from that of all genotyped segregants.)
    sH_sL_value_before_taking_absolute.xlsx (sH and sL are in two seperate Excel sheets identified with sheetnames. The attributes here are the effect size of each SNP before taking absolute value. This value is calculated using 20% of high growth rate and 20% of low growth rate segregants.)
    QTLsForAverageGrowthRate.xlsx	(row: environment, column: SNP index)
    QTLPvalueByBootStrap.xlsx	(generated by "getQTLsDiminishingReturnsByBootstrap.m", only QTLs that with P >0.05 from "AlleleFrequencyTestPValue.xlsx" are included in this bootstrap result.)
    
  Modular life model simulation scripts:
  
    geometricSimulation_step1_gValue_calculation.m (generate simulated genotype and phenotype, output Q, gValue, g1: fraction of SNPs with the same sign of effect that shows diminishing returns, g2: fraction of SNPs with same sign of effect that do not show diminishing returns, g1/(g1+g2) is the gValue when constraining the calculation to only SNPs showing the same sign of effect)
    geometricSimulation_step2_QsCorrelation.m (column 1: Q-s correlation, column 2: Q-s correlation when controlling for growth rate)
    Simulation_step2_additive.m	(same as step1 in "geometricSimulation_step1_gValue_calculation.m" but use additive model instead)
    Simulation_step1_additive.m (same as step2 in "geometricSimulation_step2_QsCorrelation.m" but use additive model instead)
    
  Other codes:
    
    QTLmapping.m (This mapping code only completes the first round of mapping, the second round should start with the residuals from the first round and the QTLs from the first round. Therefore, the variable "roundNum" need to be changed if multiple rounds of mapping are needed. You can decide how many rounds you would like to map. In this study, we mapped to the  round when no additional QTLs could be added in any environment. If you are looking for QTL mapping code that automatically deal with everything and do not care about which particular QTL mapping approach to use, I have one for another project to share upon request.)
    getQTLsDiminishingReturnsByBootstrap.m （generate "QTLPvalueByBootStrap.xlsx"）
    
Additional notes about Matlab:

    The Matlab scripts may run differently in Windows and Mac/Linux system. These scripts were writen under Windows environment. If you would like to reuse them in Mac or Linux environment, you may need to change the in/output function.
    The reason is that "xlswrite()" in matlab does not always work outside of Windows environment. Alternatives for output include dlmwrite(), writetable(), fprintf(), and etc. Alternative input could be fopen() or importdata(), and etc.

Last note:
  
    Let me know if you need any intermediate-step data/code, and I will add them to this directory.
